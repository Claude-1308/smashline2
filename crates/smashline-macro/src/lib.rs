use acmd::AcmdAttributes;
use proc_macro::TokenStream as TS;
use proc_macro2::{Group, Punct, Spacing, Span, TokenStream, TokenTree};
use proc_macro_crate::FoundCrate;
use proc_macro_error::{abort, proc_macro_error};
use quote::ToTokens;
use status::StatusAttributes;
use syn::spanned::Spanned;

mod acmd;
mod status;

macro_rules! match_kw {
    ($input:ident;$($kw:path $([$token:tt])? => $e:expr),*; _ => $e2:expr) => {{
        $(
            if $input.peek($kw) {
                let _: $kw = $input.parse()?;
                $(let _: syn::Token![$token] = $input.parse()?;)?
                $e
            } else
        )*
        {
            $e2
        }
    }}
}

macro_rules! match_suffix {
    ($str:expr; $($suffix:expr => $e:expr),*; _ => $e2:expr) => {{
        let __match_str = $str;
        $(
            if __match_str.ends_with($suffix) {
                $e
            } else
        )*
        {
            $e2
        }
    }}
}

pub(crate) use match_kw;
pub(crate) use match_suffix;

fn returns_to_breaks(stream: TokenStream) -> TokenStream {
    let mut tokens = vec![];
    for token in stream {
        match token {
            TokenTree::Ident(ident) => {
                if ident.to_string() == "return" {
                    tokens.push(TokenTree::Ident(syn::Ident::new("break", ident.span())));
                    tokens.push(TokenTree::Punct(Punct::new('\'', Spacing::Joint)));
                    tokens.push(TokenTree::Ident(syn::Ident::new(
                        "__smashline_autogenerated_break",
                        ident.span(),
                    )));
                } else {
                    tokens.push(TokenTree::Ident(ident));
                }
            }
            TokenTree::Group(group) => {
                let delim = group.delimiter();
                let stream = returns_to_breaks(group.stream());
                tokens.push(TokenTree::Group(Group::new(delim, stream)));
            }
            other => tokens.push(other),
        }
    }

    TokenStream::from_iter(tokens)
}

fn map_function_block(func: &mut syn::ItemFn) -> syn::Result<()> {
    let block: syn::Block = syn::parse2(returns_to_breaks(func.block.to_token_stream()))?;
    let block = syn::parse_quote! {
        {
            let __smashline_autogenerated_ret = '__smashline_autogenerated_break: {
                #block
            };
            std::hint::black_box("__smashline_autogenerated_blackbox");
            __smashline_autogenerated_ret
        }
    };
    func.block = block;
    Ok(())
}

fn smashline_crate_tokens() -> TokenStream {
    match proc_macro_crate::crate_name("smashline") {
        Ok(FoundCrate::Itself) => quote::quote!(crate),
        Ok(FoundCrate::Name(name)) => {
            let ident = syn::Ident::new(name.as_str(), Span::call_site());
            quote::quote!(::#ident)
        }
        Err(e) => {
            abort!(Span::call_site(), "{:?}", e);
        }
    }
}

#[proc_macro_error]
#[proc_macro_attribute]
pub fn acmd_script(attr: TS, input: TS) -> TS {
    let attributes = syn::parse_macro_input!(attr as AcmdAttributes);

    let mut function = syn::parse_macro_input!(input as syn::ItemFn);

    function
        .sig
        .inputs
        .push(syn::parse_quote!(_variadic: &mut ::smashline::Variadic));

    let vis = &function.vis;
    let ident = &function.sig.ident;

    let smashline = smashline_crate_tokens();

    let install = attributes.installer(ident, smashline.clone());

    let tokens = quote::quote! {
        #vis mod #ident {
            use super::*;
            #install

            #[#smashline::unwindable]
            #function
        }
    };

    tokens.into()
}

#[proc_macro_error]
#[proc_macro_attribute]
pub fn status_script(attrs: TS, input: TS) -> TS {
    let mut attrs = syn::parse_macro_input!(attrs as StatusAttributes);
    let mut function = syn::parse_macro_input!(input as syn::ItemFn);

    if let Err(e) = attrs.try_set_line(&function.sig.ident) {
        abort!(e);
    }

    function.sig.abi = Some(syn::Abi {
        extern_token: syn::token::Extern(function.sig.span()),
        name: Some(syn::LitStr::new("C", function.sig.span())),
    });

    let smashline = smashline_crate_tokens();

    let vis = &function.vis;
    let ident = &function.sig.ident;
    let installer = match attrs.installer(smashline, ident) {
        Ok(installer) => installer,
        Err(e) => abort!(e),
    };

    quote::quote! {
        #vis mod #ident {
            use super::*;

            pub fn install() {
                #installer
            }

            #function
        }
    }
    .into()
}

#[proc_macro_error]
#[proc_macro_attribute]
pub fn unwindable(_: TS, input: TS) -> TS {
    let mut function = syn::parse_macro_input!(input as syn::ItemFn);

    function.sig.abi = Some(syn::Abi {
        extern_token: syn::token::Extern(function.sig.span()),
        name: Some(syn::LitStr::new("C", function.sig.span())),
    });

    if let Err(e) = map_function_block(&mut function) {
        abort!(e)
    };

    let is_manually_exported = {
        let mut is_exported = false;
        for attr in function.attrs.iter() {
            if attr.path.is_ident("no_mangle") || attr.path.is_ident("export_name") {
                is_exported = true;
                break;
            }
        }
        is_exported
    };

    let export_attr = if is_manually_exported {
        quote::quote!()
    } else {
        quote::quote!(#[no_mangle])
    };

    quote::quote! {
        #export_attr
        #function
    }
    .into()
}
