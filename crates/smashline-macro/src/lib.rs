use acmd::AcmdAttributes;
use proc_macro::TokenStream as TS;
use proc_macro2::{Group, Punct, Spacing, Span, TokenStream, TokenTree};
use proc_macro_crate::FoundCrate;
use proc_macro_error::{abort, proc_macro_error};
use quote::ToTokens;
use status::{LineAttributes, StatusAttributes};
use syn::spanned::Spanned;

mod acmd;
mod status;
mod target_function;

macro_rules! match_kw {
    ($input:ident;$($kw:path $([$token:tt])? => $e:expr),*; _ => $e2:expr) => {{
        $(
            if $input.peek($kw) {
                let _: $kw = $input.parse()?;
                $(let _: syn::Token![$token] = $input.parse()?;)?
                $e
            } else
        )*
        {
            $e2
        }
    }}
}

macro_rules! match_suffix {
    ($str:expr; $($suffix:expr => $e:expr),*; _ => $e2:expr) => {{
        let __match_str = $str;
        $(
            if __match_str.ends_with($suffix) {
                $e
            } else
        )*
        {
            $e2
        }
    }}
}

pub(crate) use match_kw;
pub(crate) use match_suffix;
use target_function::InTargetAttributes;

fn returns_to_breaks(stream: TokenStream) -> TokenStream {
    let mut tokens = vec![];
    for token in stream {
        match token {
            TokenTree::Ident(ident) => {
                if ident.to_string() == "return" {
                    tokens.push(TokenTree::Ident(syn::Ident::new("break", ident.span())));
                    tokens.push(TokenTree::Punct(Punct::new('\'', Spacing::Joint)));
                    tokens.push(TokenTree::Ident(syn::Ident::new(
                        "__smashline_autogenerated_break",
                        ident.span(),
                    )));
                } else {
                    tokens.push(TokenTree::Ident(ident));
                }
            }
            TokenTree::Group(group) => {
                let delim = group.delimiter();
                let stream = returns_to_breaks(group.stream());
                tokens.push(TokenTree::Group(Group::new(delim, stream)));
            }
            other => tokens.push(other),
        }
    }

    TokenStream::from_iter(tokens)
}

fn map_function_block(func: &mut syn::ItemFn) -> syn::Result<()> {
    let block: syn::Block = syn::parse2(returns_to_breaks(func.block.to_token_stream()))?;
    let block = syn::parse_quote! {
        {
            let __smashline_autogenerated_ret = '__smashline_autogenerated_break: {
                #block
            };
            std::hint::black_box("__smashline_autogenerated_blackbox");
            __smashline_autogenerated_ret
        }
    };
    func.block = block;
    Ok(())
}

fn smashline_crate_tokens() -> TokenStream {
    match proc_macro_crate::crate_name("smashline") {
        Ok(FoundCrate::Itself) => quote::quote!(crate),
        Ok(FoundCrate::Name(name)) => {
            let ident = syn::Ident::new(name.as_str(), Span::call_site());
            quote::quote!(::#ident)
        }
        Err(e) => {
            abort!(Span::call_site(), "{:?}", e);
        }
    }
}

#[proc_macro_error]
#[proc_macro_attribute]
pub fn acmd(attr: TS, input: TS) -> TS {
    let attributes = syn::parse_macro_input!(attr as AcmdAttributes);

    let mut function = syn::parse_macro_input!(input as syn::ItemFn);

    function
        .sig
        .inputs
        .push(syn::parse_quote!(_variadic: &mut ::smashline::Variadic));

    let vis = &function.vis;
    let ident = &function.sig.ident;

    let smashline = smashline_crate_tokens();

    let install = attributes.installer(ident, smashline.clone());

    quote::quote! {
        #vis mod #ident {
            use super::*;
            #install

            #[#smashline::unwindable]
            #function
        }
    }
    .into()
}

#[proc_macro_error]
#[proc_macro_attribute]
pub fn in_target(attr: TS, input: TS) -> TS {
    let attributes = syn::parse_macro_input!(attr as InTargetAttributes);
    let mut foreign_function = syn::parse_macro_input!(input as syn::ForeignItemFn);

    foreign_function.sig.abi = Some(syn::Abi {
        extern_token: syn::token::Extern(Span::call_site()),
        name: Some(syn::LitStr::new("C", Span::call_site())),
    });

    let smashline = smashline_crate_tokens();

    let api_call = attributes.expand_api_call(smashline);
    let bare = match target_function::map_to_bare_fn(&foreign_function.sig) {
        Ok(bare) => bare,
        Err(e) => abort!(e),
    };

    let args = match target_function::extract_args(&foreign_function.sig) {
        Ok(args) => args,
        Err(e) => abort!(e),
    };

    let vis = &foreign_function.vis;
    let sig = &foreign_function.sig;
    let ident = &sig.ident;

    quote::quote! {
        #vis #sig {
            match #api_call {
                Some(addr) => {
                    let __smashline_autogenerated_call: #bare = unsafe {
                        std::mem::transmute(addr)
                    };

                    __smashline_autogenerated_call(#(#args,)*)
                },
                None => {
                    panic!(concat!("Failed to find function '", stringify!(#ident), "' in memory!"));
                }
            }
        }
    }.into()
}

#[proc_macro_error]
#[proc_macro_attribute]
pub fn line(attr: TS, input: TS) -> TS {
    let attrs = syn::parse_macro_input!(attr as LineAttributes);
    let mut function = syn::parse_macro_input!(input as syn::ItemFn);

    function.sig.abi = Some(syn::Abi {
        extern_token: syn::token::Extern(function.sig.span()),
        name: Some(syn::LitStr::new("C", function.sig.span())),
    });

    let smashline = smashline_crate_tokens();

    let vis = &function.vis;
    let ident = &function.sig.ident;
    let installer = match attrs.installer(smashline, ident) {
        Ok(installer) => installer,
        Err(e) => abort!(e),
    };

    quote::quote! {
        #vis mod #ident {
            use super::*;

            pub fn install() {
                #installer
            }

            #function
        }
    }
    .into()
}

#[proc_macro_error]
#[proc_macro_attribute]
pub fn status(attrs: TS, input: TS) -> TS {
    let mut attrs = syn::parse_macro_input!(attrs as StatusAttributes);
    let mut function = syn::parse_macro_input!(input as syn::ItemFn);

    if let Err(e) = attrs.try_set_line(&function.sig.ident) {
        abort!(e);
    }

    function.sig.abi = Some(syn::Abi {
        extern_token: syn::token::Extern(function.sig.span()),
        name: Some(syn::LitStr::new("C", function.sig.span())),
    });

    let bare_fn = match target_function::map_to_bare_fn(&function.sig) {
        Ok(bare_fn) => bare_fn,
        Err(e) => abort!(e),
    };

    if let Err(e) = status::insert_original_function(&mut function) {
        abort!(e);
    }

    let smashline = smashline_crate_tokens();

    let vis = &function.vis;
    let ident = &function.sig.ident;
    let installer = match attrs.installer(smashline.clone(), ident, false) {
        Ok(installer) => installer,
        Err(e) => abort!(e),
    };

    let original = match attrs.original(bare_fn, smashline) {
        Ok(original) => original,
        Err(e) => abort!(e),
    };

    quote::quote! {
        #vis mod #ident {
            use super::*;

            #original

            pub fn install() {
                #installer
            }

            #function
        }
    }
    .into()
}

#[proc_macro_error]
#[proc_macro_attribute]
pub fn new_status(attrs: TS, input: TS) -> TS {
    let mut attrs = syn::parse_macro_input!(attrs as StatusAttributes);
    let mut function = syn::parse_macro_input!(input as syn::ItemFn);

    if let Err(e) = attrs.try_set_line(&function.sig.ident) {
        abort!(e);
    }

    function.sig.abi = Some(syn::Abi {
        extern_token: syn::token::Extern(function.sig.span()),
        name: Some(syn::LitStr::new("C", function.sig.span())),
    });

    let smashline = smashline_crate_tokens();

    let vis = &function.vis;
    let ident = &function.sig.ident;
    let installer = match attrs.installer(smashline.clone(), ident, true) {
        Ok(installer) => installer,
        Err(e) => abort!(e),
    };

    quote::quote! {
        #vis mod #ident {
            use super::*;

            pub fn install() {
                #installer
            }

            #function
        }
    }
    .into()
}

#[proc_macro_error]
#[proc_macro_attribute]
pub fn unwindable(_: TS, input: TS) -> TS {
    let mut function = syn::parse_macro_input!(input as syn::ItemFn);

    function.sig.abi = Some(syn::Abi {
        extern_token: syn::token::Extern(function.sig.span()),
        name: Some(syn::LitStr::new("C", function.sig.span())),
    });

    if let Err(e) = map_function_block(&mut function) {
        abort!(e)
    };

    let is_manually_exported = {
        let mut is_exported = false;
        for attr in function.attrs.iter() {
            if attr.path.is_ident("no_mangle") || attr.path.is_ident("export_name") {
                is_exported = true;
                break;
            }
        }
        is_exported
    };

    let export_attr = if is_manually_exported {
        quote::quote!()
    } else {
        quote::quote!(#[no_mangle])
    };

    quote::quote! {
        #export_attr
        #function
    }
    .into()
}
